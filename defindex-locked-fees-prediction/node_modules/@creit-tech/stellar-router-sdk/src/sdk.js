import { Account, Address, Contract, Networks, rpc, scValToNative, TransactionBuilder, xdr } from "@stellar/stellar-sdk";
import { SIMULATION_ACCOUNT, StellarRouterContract } from "./types.js";
export class StellarRouterSdk {
  params;
  get simAccount() {
    return this.params?.simulationAccount || SIMULATION_ACCOUNT;
  }
  get router() {
    return new Contract(this.params?.routerContract || StellarRouterContract.v0);
  }
  constructor(params){
    this.params = params;
  }
  /**
   * This method generates the InvokeHostFunction Operation that you will be able to use within your transactions
   * @param caller - The address that is calling the contract, this account must authorize the transaction even if none of the invocations require authorization.
   * @param invocations - All the invocations the proxy will execute
   */ exec(caller, invocations) {
    const args = invocations.map((invocation)=>{
      switch(invocation.version){
        case "v0":
          return xdr.ScVal.scvVec([
            new Address(invocation.contract.toString()).toScVal(),
            xdr.ScVal.scvSymbol(invocation.method),
            xdr.ScVal.scvVec(invocation.args)
          ]);
        case "v1":
          return xdr.ScVal.scvVec([
            new Address(invocation.contract.toString()).toScVal(),
            xdr.ScVal.scvSymbol(invocation.method),
            xdr.ScVal.scvVec(invocation.args),
            xdr.ScVal.scvBool(invocation.canFail === true)
          ]);
        default:
          throw new Error(`Invocation version is not supported.`);
      }
    });
    return this.router.call("exec", new Address(caller.toString()).toScVal(), xdr.ScVal.scvVec(args));
  }
  async simResult(invocations, opts) {
    if (!this.params?.rpcUrl) {
      throw new Error("No `rpcUrl` parameter was provided to the SDK.");
    }
    const tx = new TransactionBuilder(new Account(opts?.source || this.simAccount, "0"), {
      networkPassphrase: Networks.PUBLIC,
      fee: "0"
    }).setTimeout(0).addOperation(this.exec(opts?.caller || this.simAccount, invocations)).build();
    const sim = await new rpc.Server(this.params.rpcUrl, {
      allowHttp: true
    }).simulateTransaction(tx);
    if (rpc.Api.isSimulationError(sim)) throw sim.error;
    return scValToNative(sim.result?.retval);
  }
}
//# sourceMappingURL=sdk.js.map